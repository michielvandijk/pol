t.tests <- seq(0, n)
while (power < power.level[1]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)
power <- sum(apply(t.tests, function(x) abs(x)) > CV / n)
while (power < power.level[2]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A, B)
power <- sum(apply(t.tests, function(x) abs(x)) > CV / n)
}
}
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)
power <- sum(apply(t.tests, function(x) abs(x)) > CV / n)
N <- 64
muA <- 3
muB <- 2.5
sd <- 1
n <- 100
x <- seq(0, n)
n <- 2
power.level <- c(0.8, 0.9)
power <- NULL
t.tests <- seq(0, n)
power <- 0
t.tests <- seq(0, n)
while (power < power.level[1]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)
power <- sum(apply(t.tests, function(x) abs(x)) > CV / n)
while (power < power.level[2]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A, B)
power <- sum(apply(t.tests, function(x) abs(x)) > CV / n)
}
}
while (power < power.level[1]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)
power <- sum(sapply(t.tests, function(x) abs(x)) > CV / n)
while (power < power.level[2]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A, B)
power <- sum(sapply(t.tests, function(x) abs(x)) > CV / n)
}
}
t.tests <- seq(0, n)
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)
t.test(A,B)
class(t.test(A,B))
str(t.test(A,B))
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)$statistic
power <- sum(sapply(t.tests, function(x) abs(x)) > CV / n)
class(t.test(A,B)$statistic)
set.seed(4444)
muA.1 <- 2.7
muA.2 <- 3.4
muB.1 <- 2.5
sd <- 1
n <- 2
power.level <- c(0.8, 0.9)
power <- 0
t.tests <- seq(0, n)
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)$statistic
power <- sum(sapply(t.tests, function(x) abs(x)) > CV / n)
set.seed(4444)
muA.1 <- 2.7
muA.2 <- 3.4
muB.1 <- 2.5
sd <- 1
n <- 2
power.level <- c(0.8, 0.9)
power <- 0
t.tests <- seq(0, n)
while (power < power.level[1]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)$statistic
power <- sum(lapply(t.tests, function(x) abs(x)) > CV / n)
while (power < power.level[2]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A, B)$statistic
power <- sum(lapply(t.tests, function(x) abs(x)) > CV / n)
}
}
CV <- qt(0.975, df = 2*N - 2)
N <- 64
muA <- 3
muB <- 2.5
sd <- 1
n <- 100
x <- seq(0, n)
test.stat <- function(A, B){
t.test(A, B, var.equal = TRUE)
}
set.seed(4444)
for (i in 1:n){
A <- rnorm(N, muA, sd)
B <- rnorm(N, muB, sd)
x[i] <- as.matrix(test.stat(A,B))
}
CV <- qt(0.975, df = 2*N - 2)
set.seed(4444)
muA.1 <- 2.7
muA.2 <- 3.4
muB.1 <- 2.5
sd <- 1
n <- 2
power.level <- c(0.8, 0.9)
power <- 0
t.tests <- seq(0, n)
while (power < power.level[1]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)$statistic
power <- sum(lapply(t.tests, function(x) abs(x)) > CV / n)
while (power < power.level[2]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A, B)$statistic
power <- sum(lapply(t.tests, function(x) abs(x)) > CV / n)
}
}
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)$statistic
power <- sum(lapply(t.tests, function(x) abs(x)) > CV / n)
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)$statistic
power <- sum(abs(t.tests) > CV/n)
power
while (power < power.level[1]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)$statistic
power <- sum(abs(t.tests) > CV/n)
}
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)$statistic
summary(t.tests)
t.tests <- numeric()
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
t.tests[i] <- t.test(A,B)$statistic
t.tests <- numeric()
while (power < power.level[1]){
n <- n + 1
A <- rnorm(n, muA, sd)
B <- rnorm(n, muB, sd)
reject <- reject + (abs(t.test(A,B)$statistic) > CV/n)
# t.tests[i] <- t.test(A,B)$statistic
power <- sum(abs(t.tests) > CV/n)
# power <- sum(lapply(t.tests, function(x) abs(x)) > CV / n)
}
library(faraway)
data("prostate")
lm0 <- lm(lpsa ~ ., data=prostate)
summary(lm0)
coef(summary(g))
coef(summary(lm0))
summary(lm0)$r.squared
optins(scipen=999)
options(scipen=999)
coef(summary(lm0))
lm0 <- update(lm0, . ~ , -gleason)
lm0 <- update(lm0, . ~, -gleason)
lm0 <- update(lm0, . ~ -gleason)
coef(summary(lm0))
?update
lm0 <- lm(lpsa ~ ., data=prostate)
lm0 <- update(lm0, . ~ . -gleason)
coef(summary(lm0))
lm0 <- update(lm0, . ~ . -lcp)
coef(summary(lm0))
lm0 <- update(lm0, . ~ . -pgg45)
coef(summary(lm0))
lm0 <- update(lm0, . ~ . -age)
coef(summary(lm0))
lm0 <- update(lm0, . ~ . -lbph)
coef(summary(lm0))
summary(lm0)$r.squared
lm0 <- lm(lpsa ~ ., data=prostate)
summary(lm0)$r.squared
steppres <- step(lm0, 2)
lm0 <- lm(lpsa ~ ., data=prostate)
steppres <- step(lm0, 2)
steppres <- step(lm0, steps=2)
steppres <- step(lm0, steps=4)
steppres <- step(lm0, steps=10)
steppres <- step(lm0, steps=8)
steppres <- step(lm0, steps=7)
data("prostate")
lm0 <- lm(lpsa ~ ., data=prostate)
# backward elimination using hypothesis testing
coef(summary(lm0))
# original r-squared
summary(lm0)$r.squared
# drop gleason
lm0 <- update(lm0, . ~ . -gleason)
coef(summary(lm0))
# drop lcp
lm0 <- update(lm0, . ~ . -lcp)
coef(summary(lm0))
# drop pgg45
lm0 <- update(lm0, . ~ . -pgg45)
coef(summary(lm0))
# drop age
lm0 <- update(lm0, . ~ . -age)
coef(summary(lm0))
# drop lbph
lm0 <- update(lm0, . ~ . -lbph)
coef(summary(lm0))
# final r-squared - but you didn't drop the intercept!
summary(lm0)$r.squared
lm0 <- lm(lpsa ~ ., data=prostate)
steppres <- step(lm0, steps=7)  # last model has AIC=-61.37
?step
lm0 <- lm(lpsa ~ ., data=prostate)
x <- model.matrix(lm0)[, -1]
names(prostate)
y <- prostate$lpsa
adjr <- leasp(x, y, method="adjr2")
adjr <- leaps(x, y, method="adjr2")
library(leaps)
install.packages("leaps")
library(leaps)
adjr <- leaps(x, y, method="adjr2")
maxadjr(adjr, 8)
?maxadjr
str(adjr)
install.packages("MuMIN")
install.packages("MuMIn")
library(MuMIn)
g <- lm(lpsa ~ ., prostate)
dredge(g)
?dredge
g <- lm(lpsa ~ ., prostate)
x <- model.matrix(g)[, -1]
y <- prostate$lpsa
g <- leaps(x, y)
cpplot(g)
Cpplot(g)
M <- NULL
for(i in 1:101){
M <- cbind(M, rnorm(500))
}
model <- lm(M[, 1] ~ ., data=M)
M <- data.frame
M <- data.frame()
for(i in 1:101){
M <- cbind(M, rnorm(500))
}
M <- NULL
for(i in 1:101){
M <- cbind(M, rnorm(500))
}
M <- as.data.frame(M)
model <- lm(M[, 1] ~ ., data=M)
summary(model)
model <- lm(M[, 1] ~ M[, 2:101], data=M)
names(M)
model <- lm(V1 ~ ., data=M)
summary(model)
coef(summary(model))
summary(model)
M <- NULL
set.seed(5367)
for(i in 1:101){
M <- cbind(M, rnorm(500))
}
M <- as.data.frame(M)
model <- lm(V1 ~ ., data=M)
summary(model)
names(M)
summary(model)
model2 <-lm(V1 ~ V23 + V29 + V35, data=M)
summary(model)
summary(model2)
M <- as.data.frame(M)
model <- lm(V1 ~ ., data=M)
summary(model)
library(leaps)
x <- model.matrix(model)[, -1]
y <- model[, 1]
y <- M$V1
adjr <- leaps(x, y, method="adjr2")
adjr <- regsubsets(x, y, method="adjr2")
?regsubsets
adjr <- regsubsets(V1 ~ ., data=M, nbest=1, nvmax=3, intercept=TRUE, method=c("exhaustive"), really.big=TRUE)
b <- regsubsets(V1 ~ ., data=M, nbest=1, nvmax=3, intercept=TRUE, method=c("exhaustive"), really.big=TRUE)
rs <- summary(b)
rs$cp
M2 <- NULL
set.seed(5367)
for(i in 1:10){
M2 <- cbind(M2, rnorm(500))
}
M2 <- as.data.frame(M2)
M2 <- NULL
for(i in 1:100){
set.seed(5367)
M2 <- cbind(M2, rnorm(500))
}
M2 <- as.data.frame(M2)
str(rs)
validate <- model$coefficients[24]*M2$V23 +
model$coefficients[30]*M2$V29 +
model$coefficients[36]*M2$V35
plot(validate ~ M$V1)
M2 <- NULL
for(i in 1:100){
M2 <- cbind(M2, rnorm(500))
}
M2 <- as.data.frame(M2)
validate <- model$coefficients[24]*M2$V23 +
model$coefficients[30]*M2$V29 +
model$coefficients[36]*M2$V35
plot(validate ~ M$V1)
M2 <- NULL
set.seed(853)
for(i in 1:100){
M2 <- cbind(M2, rnorm(500))
}
M2 <- as.data.frame(M2)
validate <- model$coefficients[24]*M2$V23 +
model$coefficients[30]*M2$V29 +
model$coefficients[36]*M2$V35
plot(validate ~ M$V1)
rm(list=ls())
# -------------------------------------
# read in ward and constituency link
# table from the NBS 2015
setwd("C:/Users/Tomas/Documents/LEI/pol/data")
# use regex to order the information the way
# that you want
x <- readLines("MAJIMBO NA KATA 2015 FINAL.txt")
x2 <- gsub("(?<=[a-zA-Z])(\\s|\\s{2})(?=[a-zA-Z])", "-", x, perl=TRUE)
x3 <- gsub("(?<=\\d)(\\s{0,})(?!\\w)", "", x2, perl=TRUE)
x4 <- gsub("(\\s)(?!\\w)", "", x3, perl=TRUE)
x5 <- gsub("(?<!\\w)(\\s)", "", x4, perl = TRUE)
# select on length of resulting strings
list <- lapply(x5, function(elt) strsplit(elt, " "))
s <- sapply(list, function(elt) length(elt[[1]]))
bad <- s %in% 0 | s %in% 1
x6 <- x5[!bad]
# function for filling gaps with NA values
# need to change this for new data
extender <- function(x){
if(length(x) == 3){
x <- c(NA, NA, NA, x)
} else if (length(x)==4){
x <- c(NA, NA, x)
} else if (length(x)==5){
x <- c(NA, x)
}
return(x)
}
# split on whitespace and create a new dataframe
x7 <- strsplit(x6, " ")
x8 <- lapply(x7, function(elt) extender(elt))
# create new dataframe for holdig this information
df <- data.frame(
reg=sapply(x8, function(elt) return(elt[1])),
dis=sapply(x8, function(elt) return(elt[2])),
con=sapply(x8, function(elt) return(elt[3])),
N1=sapply(x8, function(elt) return(elt[4])),
ward=sapply(x8, function(elt) return(elt[5])),
N2=sapply(x8, function(elt) return(elt[6]))
)
# read in filler functions and back fill
# all the values that are NA
source("C:/Users/Tomas/Documents/LEI/Afripol/TZA/code/filler.R")
df$reg <- backer(df$reg)
df$dis <- backer(df$dis)
df$con <- backer(df$con)
# put hyphenated values back to normal
df$reg <- gsub("-", " ", df$reg)
df$dis <- gsub("-", " ", df$dis)
df$con <- gsub("-", " ", df$con)
df$ward <- gsub("-", " ", df$ward)
# get rid of commas and make integers of variables
df$N2 <- gsub(",", "", df$N2)
df$N2 <- as.integer(df$N2)
rm(list=ls()[!ls() %in% "df"])
leg10 <- read.table("C:/Users/Tomas/Documents/LEI/pol/data/leg10.txt", header=TRUE)
table(leg10$const %in% df$con)
table(unique(leg10$const) %in% unique(df$con))
head(unique(leg10$const)[!unique(leg10$const) %in% unique(df$con)])
nrow(unique(leg10$const)[!unique(leg10$const) %in% unique(df$con)])
length(unique(leg10$const)[!unique(leg10$const) %in% unique(df$con)])
names(leg10)
tsts <- unique(select(leg10, region, const))
library(dplyr)
tsts <- unique(select(leg10, region, const))
tst <- unique(select(leg10, region, const))
missing <- toupper(tst$const) %in% toupper(df$con)
sum(missing)
missing <- !toupper(tst$const) %in% toupper(df$con)
sum(missing)
tst[missing, ]
islands <- toupper(islands)
islands <- c("Kaskazini Unguja", "Kusini Unguja", "Mjini Magharibi", "Kaskazini Pemba", "Kusini Pemba")
islands <- toupper(islands)
missing <- !toupper(tst$const) %in% toupper(df$con) & !toupper(tst$const) %in% islands
tst[missing, ]
leg10 <- read.table("C:/Users/Tomas/Documents/LEI/pol/data/leg10.txt", header=TRUE)
tst <- unique(select(leg10, region, const))
islands <- c("Kaskazini Unguja", "Kusini Unguja", "Mjini Magharibi", "Kaskazini Pemba", "Kusini Pemba")
islands <- toupper(islands)
tst <- tst[!tst$region %in% islands, ]
missing <- !toupper(tst$const) %in% toupper(df$con)
sum(missing)
tst[missing, ]
# -------------------------------------
# read in ward and constituency link
# table from the NBS 2015
setwd("C:/Users/Tomas/Documents/LEI/pol/data")
# use regex to order the information the way
# that you want
x <- readLines("MAJIMBO NA KATA 2015 FINAL.txt")
x2 <- gsub("(?<=[a-zA-Z])(\\s|\\s{2})(?=[a-zA-Z])", "-", x, perl=TRUE)
x3 <- gsub("(?<=\\d)(\\s{0,})(?!\\w)", "", x2, perl=TRUE)
x4 <- gsub("(\\s)(?!\\w)", "", x3, perl=TRUE)
x5 <- gsub("(?<!\\w)(\\s)", "", x4, perl = TRUE)
# select on length of resulting strings
list <- lapply(x5, function(elt) strsplit(elt, " "))
s <- sapply(list, function(elt) length(elt[[1]]))
bad <- s %in% 0 | s %in% 1
x6 <- x5[!bad]
# function for filling gaps with NA values
# need to change this for new data
extender <- function(x){
if(length(x) == 3){
x <- c(NA, NA, NA, x)
} else if (length(x)==4){
x <- c(NA, NA, x)
} else if (length(x)==5){
x <- c(NA, x)
}
return(x)
}
# split on whitespace and create a new dataframe
x7 <- strsplit(x6, " ")
x8 <- lapply(x7, function(elt) extender(elt))
# create new dataframe for holdig this information
df <- data.frame(
reg=sapply(x8, function(elt) return(elt[1])),
dis=sapply(x8, function(elt) return(elt[2])),
con=sapply(x8, function(elt) return(elt[3])),
N1=sapply(x8, function(elt) return(elt[4])),
ward=sapply(x8, function(elt) return(elt[5])),
N2=sapply(x8, function(elt) return(elt[6]))
)
# read in filler functions and back fill
# all the values that are NA
source("C:/Users/Tomas/Documents/LEI/Afripol/TZA/code/filler.R")
df$reg <- backer(df$reg)
df$dis <- backer(df$dis)
df$con <- backer(df$con)
# put hyphenated values back to normal
df$reg <- gsub("-", " ", df$reg)
df$dis <- gsub("-", " ", df$dis)
df$con <- gsub("-", " ", df$con)
df$ward <- gsub("-", " ", df$ward)
# get rid of commas and make integers of variables
df$N2 <- gsub(",", "", df$N2)
df$N2 <- as.integer(df$N2)
rm(list=ls()[!ls() %in% "df"])
leg10 <- read.table("C:/Users/Tomas/Documents/LEI/pol/data/leg10.txt", header=TRUE)
tst <- unique(select(leg10, region, const))
islands <- c("Kaskazini Unguja", "Kusini Unguja", "Mjini Magharibi", "Kaskazini Pemba", "Kusini Pemba")
islands <- toupper(islands)
tst <- tst[!tst$region %in% islands, ]
missing <- !toupper(tst$const) %in% toupper(df$con)
sum(missing) # 57
tst[missing, ]
tst[missing, ][1, 2]
as.character(tst[missing, ][1, 2])
